package MalwareAnalysis

/*
 * Author: Oliver McLane
 *
 * Package MalwareAnalysis provides functions for interacting with the Hybrid Analysis API to analyze and retrieve details of malware files.
 * The functions in this package allow users to submit files for analysis, retrieve analysis summaries, and search for file details using hash values.
 */
import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"net/url"
)

// AnalyzeFile function submits a file for analysis and returns the analysis summary.
func AnalyzeFile(file io.Reader, fileName string, apiKey string) (string, error) {
	// Base URL for the Hybrid Analysis API
	baseURL := "https://www.hybrid-analysis.com/api/v2"

	// Create a new multipart writer
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	// Add the file field to the request body
	fileWriter, err := writer.CreateFormFile("file", fileName)
	if err != nil {
		return "", err
	}
	fmt.Println(fileName)
	_, err = io.Copy(fileWriter, file)
	if err != nil {
		return "", err
	}

	// Add environment_id field to specify the analysis environment
	if err := writer.WriteField("environment_id", "140"); err != nil {
		return "", err
	}

	// Close the multipart writer
	writer.Close()

	// Send POST request to submit the file for analysis
	req, err := http.NewRequest("POST", baseURL+"/submit/file", &requestBody)
	if err != nil {
		return "", err
	}
	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.Header.Set("api-key", apiKey)
	req.Header.Set("User-Agent", "Falcon")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Handle non-200 status codes
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		// Read the response body to provide more information about the failure
		responseBody, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return "", fmt.Errorf("request failed with status: %s", resp.Status)
		}
		return "", fmt.Errorf("request failed with status: %s, response body: %s", resp.Status, string(responseBody))
	}

	// Read the response body
	responseBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	// Parse the JSON response to extract the job ID
	var response map[string]interface{}
	if err := json.Unmarshal(responseBody, &response); err != nil {
		return "", err
	}

	jobID, ok := response["job_id"].(string)
	if !ok {
		return "", errors.New("job_id not found in response")
	}

	// Construct URL for the analysis summary endpoint
	summaryURL := fmt.Sprintf("%s/report/%s/summary", baseURL, jobID)

	// Send GET request to retrieve the analysis summary
	reqSummary, err := http.NewRequest("GET", summaryURL, nil)
	if err != nil {
		return "", err
	}
	reqSummary.Header.Set("api-key", apiKey)
	reqSummary.Header.Set("User-Agent", "Falcon")

	respSummary, err := client.Do(reqSummary)
	if err != nil {
		return "", err
	}
	defer respSummary.Body.Close()

	if respSummary.StatusCode != http.StatusOK {
		return "", fmt.Errorf("summary request failed with status: %s", respSummary.Status)
	}

	// Read the summary response body
	summaryBody, err := ioutil.ReadAll(respSummary.Body)
	if err != nil {
		return "", err
	}

	// Return the summary response
	return string(summaryBody), nil
}

// DetailsHash function retrieves details of a file by its hash value.
func DetailsHash(fileHash string, apiKey string) (string, error) {
	// Base URL for the Hybrid Analysis API
	baseURL := "https://www.hybrid-analysis.com/api/v2"

	// Construct query parameters
	queryParams := url.Values{
		"hash": []string{fileHash},
	}

	// Encode query parameters as form data
	formData := bytes.NewBufferString(queryParams.Encode())

	// Create a POST request to search by hash
	req, err := http.NewRequest("POST", baseURL+"/search/hash", formData)
	req.Header.Set("api-key", apiKey)
	req.Header.Set("User-Agent", "Falcon")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	// Send the POST request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Handle non-200 status codes
	if resp.StatusCode != http.StatusOK {
		return "", nil
	}

	// Parse the response body
	var responses []HashResponse
	if err := json.NewDecoder(resp.Body).Decode(&responses); err != nil {
		return "", err
	}

	// Encode the response struct slice into JSON string
	jsonResponse, err := json.Marshal(responses)
	if err != nil {
		return "", err
	}

	return string(jsonResponse), nil
}

// HashResponse struct represents the response format for file hash details.
type HashResponse struct {
	Verdict         string        `json:"verdict"`
	ThreatLevel     int           `json:"threat_score"`
	MitreAttacks    []MitreAttack `json:"mitre_attcks"`
	Type            string        `json:"type"`
	VX_Family       string        `json:"vx_family"`
	TotalSignatures int           `json:"total_signatures"`
	Hosts           []string      `json:"hosts"`
	Domains         []string      `json:"domains"`
	Tags            []string      `json:"tags"`
	Signatures      []Signature   `json:"signatures"`
}

// AnalysisResponse struct represents the response format for analysis details.
type AnalysisResponse struct {
	Verdict      string        `json:"verdict"`
	ThreatLevel  int           `json:"threat_level"`
	MitreAttacks []MitreAttack `json:"mitre_attcks"`
	Type         string        `json:"type"`
	VX_Family    string        `json:"vx_family"`
	DateAnalysis string        `json:"analysis_start_time"`
	Hosts        []string      `json:"hosts"`
	Domains      []string      `json:"domains"`
	Tags         []string      `json:"tags"`
	Signatures   []Signature   `json:"signatures"`
}

// Signature struct represents the signature details.
type Signature struct {
	ThreatLevel      int    `json:"threat_level"`
	ThreatLevelHuman string `json:"threat_level_human"`
	Category         string `json:"category"`
	Identifier       string `json:"identifier"`
	Type             int    `json:"type"`
	Relevance        int    `json:"relevance"`
	Name             string `json:"name"`
	Description      string `json:"description"`
	Origin           string `json:"origin"`
	ATTCKID          string `json:"attck_id"`
	CAPECID          string `json:"capec_id"`
	ATTCKIDWiki      string `json:"attck_id_wiki"`
}

// MitreAttack struct represents MITRE ATT&CK details.
type MitreAttack struct {
	Tactic     string `json:"tactic"`
	Technique  string `json:"technique"`
	AttckID    string `json:"attck_id"`
	AttackWiki string `json:"attck_id_wiki"`
}
